{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar __ = require('underscore');\n\nvar base = require('./base');\n/**\n * @constructor\n *\n * @param {string} addr - Hostname or ip addres\n * @param {PingConfig} config - Config object in probe()\n */\n\n\nfunction WinParser(addr, config) {\n  base.call(this, addr, config);\n  this._ipv4Regex = /^([0-9]{1,3}\\.){3}[0-9]{1,3}$/;\n}\n\nutil.inherits(WinParser, base);\n/**\n * Process output's header\n * @param {string} line - A line from system ping\n */\n\nWinParser.prototype._processHeader = function (line) {\n  // XXX: Expect to find [****] when pinging domain like google.com\n  //      Read fixture/win/**/* for the detail\n  var isPingNumeric = line.indexOf('[') === -1; // Get host and numeric_host\n\n  var tokens = line.split(' ');\n\n  if (isPingNumeric) {\n    // For those missing [***], get the first token which match IPV4 regex\n    this._response.host = __.find(tokens, function (t) {\n      return this._ipv4Regex.test(t);\n    }, this);\n    this._response.numeric_host = this._response.host;\n  } else {\n    // For those has [***], anchor with such token\n    var numericHost = __.find(tokens, function (t) {\n      return t.indexOf('[') !== -1;\n    }, this);\n\n    var numericHostIndex = tokens.indexOf(numericHost);\n    var match = /\\[(.*)\\]/.exec(numericHost);\n\n    if (match) {\n      // Capture IP inside [] only. refs #71\n      this._response.numeric_host = match[1];\n    } else {\n      // Otherwise, just mark as NA to indicate an error\n      this._response.numeric_host = 'NA';\n    }\n\n    this._response.host = tokens[numericHostIndex - 1];\n  }\n\n  this._changeState(this.STATES.BODY);\n};\n/**\n * Process ipv6 output's body\n * @param {string} line - A line from system ping\n */\n\n\nWinParser.prototype._processIPV6Body = function (line) {\n  var tokens = line.split(' ');\n\n  var dataFields = __.filter(tokens, function (token) {\n    var isDataField = token.indexOf('=') >= 0 || token.indexOf('<') >= 0;\n    return isDataField;\n  }); // refs #65: Support system like french which has an extra space\n\n\n  dataFields = __.map(dataFields, function (dataField) {\n    var ret = dataField;\n    var dataFieldIndex = tokens.indexOf(dataField);\n    var nextIndex = dataFieldIndex + 1; // Append the missing *ms*\n\n    if (nextIndex < tokens.length) {\n      if (tokens[nextIndex] === 'ms') {\n        ret += 'ms';\n      }\n    }\n\n    return ret;\n  });\n  var expectDataFieldInReplyLine = 1;\n\n  if (dataFields.length >= expectDataFieldInReplyLine) {\n    // XXX: Assume time will alaways get keyword ms for all language\n    var timeKVP = __.find(dataFields, function (dataField) {\n      return dataField.search(/(ms|мс)/i) >= 0;\n    });\n\n    var regExp = /([0-9.]+)/;\n    var match = regExp.exec(timeKVP);\n\n    this._times.push(parseFloat(match[1], 10));\n  }\n};\n/**\n * Process ipv4 output's body\n * @param {string} line - A line from system ping\n */\n\n\nWinParser.prototype._processIPV4Body = function (line) {\n  var tokens = line.split(' ');\n\n  var byteTimeTTLFields = __.filter(tokens, function (token) {\n    var isDataField = token.indexOf('=') >= 0 || token.indexOf('<') >= 0;\n    return isDataField;\n  });\n\n  var expectDataFieldInReplyLine = 3;\n  var isReplyLine = byteTimeTTLFields.length >= expectDataFieldInReplyLine;\n\n  if (isReplyLine) {\n    var packetSize = this._pingConfig.packetSize;\n\n    var byteField = __.find(byteTimeTTLFields, function (dataField) {\n      var packetSizeToken = util.format('=%d', packetSize);\n      var isByteField = dataField.indexOf(packetSizeToken) >= 0;\n      return isByteField;\n    }); // XXX: Assume time field will always be next of byte field\n\n\n    var byteFieldIndex = byteTimeTTLFields.indexOf(byteField);\n    var timeFieldIndex = byteFieldIndex + 1;\n    var timeKVP = byteTimeTTLFields[timeFieldIndex];\n    var regExp = /([0-9.]+)/;\n    var match = regExp.exec(timeKVP);\n\n    this._times.push(parseFloat(match[1], 10));\n  }\n};\n/**\n * Process output's body\n * @param {string} line - A line from system ping\n */\n\n\nWinParser.prototype._processBody = function (line) {\n  var isPingSummaryLineShown = line.slice(-1) === ':';\n\n  if (isPingSummaryLineShown) {\n    this._changeState(this.STATES.FOOTER);\n\n    return;\n  }\n\n  var isIPV6 = this._pingConfig.v6;\n\n  if (isIPV6) {\n    this._processIPV6Body(line);\n  } else {\n    this._processIPV4Body(line);\n  }\n};\n/**\n * Process output's footer\n * @param {string} line - A line from system ping\n */\n\n\nWinParser.prototype._processFooter = function (line) {\n  var packetLoss = line.match(/([\\d.]+)%/);\n\n  if (packetLoss) {\n    this._response.packetLoss = parseFloat(packetLoss[1], 10);\n  } // XXX: Assume there is a keyword ms\n\n\n  if (line.search(/(ms|мсек)/i) >= 0) {\n    // XXX: Assume the ordering is Min Max Avg\n    var regExp = /([0-9.]+)/g;\n    var m1 = regExp.exec(line);\n    var m2 = regExp.exec(line);\n    var m3 = regExp.exec(line);\n\n    if (__.all([m1, m2, m3])) {\n      this._response.min = parseFloat(m1[1], 10);\n      this._response.max = parseFloat(m2[1], 10);\n      this._response.avg = parseFloat(m3[1], 10);\n\n      this._changeState(this.STATES.END);\n    }\n  }\n};\n\nmodule.exports = WinParser;","map":{"version":3,"sources":["/home/maira/Desktop/system-ping-project/client/node_modules/ping/lib/parser/win.js"],"names":["util","require","__","base","WinParser","addr","config","call","_ipv4Regex","inherits","prototype","_processHeader","line","isPingNumeric","indexOf","tokens","split","_response","host","find","t","test","numeric_host","numericHost","numericHostIndex","match","exec","_changeState","STATES","BODY","_processIPV6Body","dataFields","filter","token","isDataField","map","dataField","ret","dataFieldIndex","nextIndex","length","expectDataFieldInReplyLine","timeKVP","search","regExp","_times","push","parseFloat","_processIPV4Body","byteTimeTTLFields","isReplyLine","packetSize","_pingConfig","byteField","packetSizeToken","format","isByteField","byteFieldIndex","timeFieldIndex","_processBody","isPingSummaryLineShown","slice","FOOTER","isIPV6","v6","_processFooter","packetLoss","m1","m2","m3","all","min","max","avg","END","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar util = require('util');\nvar __ = require('underscore');\n\nvar base = require('./base');\n\n/**\n * @constructor\n *\n * @param {string} addr - Hostname or ip addres\n * @param {PingConfig} config - Config object in probe()\n */\nfunction WinParser(addr, config) {\n    base.call(this, addr, config);\n    this._ipv4Regex = /^([0-9]{1,3}\\.){3}[0-9]{1,3}$/;\n}\n\nutil.inherits(WinParser, base);\n\n/**\n * Process output's header\n * @param {string} line - A line from system ping\n */\nWinParser.prototype._processHeader = function (line) {\n    // XXX: Expect to find [****] when pinging domain like google.com\n    //      Read fixture/win/**/* for the detail\n    var isPingNumeric = line.indexOf('[') === -1;\n\n    // Get host and numeric_host\n    var tokens = line.split(' ');\n\n    if (isPingNumeric) {\n        // For those missing [***], get the first token which match IPV4 regex\n        this._response.host = __.find(tokens, function (t) {\n            return this._ipv4Regex.test(t);\n        }, this);\n        this._response.numeric_host = this._response.host;\n    } else {\n        // For those has [***], anchor with such token\n        var numericHost = __.find(tokens, function (t) {\n            return t.indexOf('[') !== -1;\n        }, this);\n        var numericHostIndex = tokens.indexOf(numericHost);\n        var match = /\\[(.*)\\]/.exec(numericHost);\n\n        if (match) {\n            // Capture IP inside [] only. refs #71\n            this._response.numeric_host = match[1];\n        } else {\n            // Otherwise, just mark as NA to indicate an error\n            this._response.numeric_host = 'NA';\n        }\n        this._response.host = tokens[numericHostIndex - 1];\n    }\n\n    this._changeState(this.STATES.BODY);\n};\n\n/**\n * Process ipv6 output's body\n * @param {string} line - A line from system ping\n */\nWinParser.prototype._processIPV6Body = function (line) {\n    var tokens = line.split(' ');\n    var dataFields = __.filter(tokens, function (token) {\n        var isDataField = token.indexOf('=') >= 0 || token.indexOf('<') >= 0;\n        return isDataField;\n    });\n\n    // refs #65: Support system like french which has an extra space\n    dataFields = __.map(dataFields, function (dataField) {\n        var ret = dataField;\n        var dataFieldIndex = tokens.indexOf(dataField);\n        var nextIndex = dataFieldIndex + 1;\n\n        // Append the missing *ms*\n        if (nextIndex < tokens.length) {\n            if (tokens[nextIndex] === 'ms') {\n                ret += 'ms';\n            }\n        }\n\n        return ret;\n    });\n\n    var expectDataFieldInReplyLine = 1;\n    if (dataFields.length >= expectDataFieldInReplyLine) {\n        // XXX: Assume time will alaways get keyword ms for all language\n        var timeKVP = __.find(dataFields, function (dataField) {\n            return dataField.search(/(ms|мс)/i) >= 0;\n        });\n        var regExp = /([0-9.]+)/;\n        var match = regExp.exec(timeKVP);\n\n        this._times.push(parseFloat(match[1], 10));\n    }\n};\n\n/**\n * Process ipv4 output's body\n * @param {string} line - A line from system ping\n */\nWinParser.prototype._processIPV4Body = function (line) {\n    var tokens = line.split(' ');\n    var byteTimeTTLFields = __.filter(tokens, function (token) {\n        var isDataField = token.indexOf('=') >= 0 || token.indexOf('<') >= 0;\n        return isDataField;\n    });\n\n    var expectDataFieldInReplyLine = 3;\n    var isReplyLine = byteTimeTTLFields.length >= expectDataFieldInReplyLine;\n    if (isReplyLine) {\n        var packetSize = this._pingConfig.packetSize;\n        var byteField = __.find(byteTimeTTLFields, function (dataField) {\n            var packetSizeToken = util.format('=%d', packetSize);\n            var isByteField = dataField.indexOf(packetSizeToken) >= 0;\n            return isByteField;\n        });\n\n        // XXX: Assume time field will always be next of byte field\n        var byteFieldIndex = byteTimeTTLFields.indexOf(byteField);\n        var timeFieldIndex = byteFieldIndex + 1;\n        var timeKVP = byteTimeTTLFields[timeFieldIndex];\n\n        var regExp = /([0-9.]+)/;\n        var match = regExp.exec(timeKVP);\n\n        this._times.push(parseFloat(match[1], 10));\n    }\n};\n\n/**\n * Process output's body\n * @param {string} line - A line from system ping\n */\nWinParser.prototype._processBody = function (line) {\n    var isPingSummaryLineShown = line.slice(-1) === ':';\n    if (isPingSummaryLineShown) {\n        this._changeState(this.STATES.FOOTER);\n        return;\n    }\n\n    var isIPV6 = this._pingConfig.v6;\n    if (isIPV6) {\n        this._processIPV6Body(line);\n    } else {\n        this._processIPV4Body(line);\n    }\n};\n\n/**\n * Process output's footer\n * @param {string} line - A line from system ping\n */\nWinParser.prototype._processFooter = function (line) {\n    var packetLoss = line.match(/([\\d.]+)%/);\n    if (packetLoss) {\n        this._response.packetLoss = parseFloat(packetLoss[1], 10);\n    }\n\n    // XXX: Assume there is a keyword ms\n    if (line.search(/(ms|мсек)/i) >= 0) {\n        // XXX: Assume the ordering is Min Max Avg\n        var regExp = /([0-9.]+)/g;\n        var m1 = regExp.exec(line);\n        var m2 = regExp.exec(line);\n        var m3 = regExp.exec(line);\n\n        if (__.all([m1, m2, m3])) {\n            this._response.min = parseFloat(m1[1], 10);\n            this._response.max = parseFloat(m2[1], 10);\n            this._response.avg = parseFloat(m3[1], 10);\n            this._changeState(this.STATES.END);\n        }\n    }\n};\n\nmodule.exports = WinParser;\n"]},"metadata":{},"sourceType":"script"}