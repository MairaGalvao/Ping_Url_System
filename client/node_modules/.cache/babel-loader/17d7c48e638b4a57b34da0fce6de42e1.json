{"ast":null,"code":"\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\n\nconst PoolOptions = require(\"./PoolOptions\");\n\nconst ResourceRequest = require(\"./ResourceRequest\");\n\nconst ResourceLoan = require(\"./ResourceLoan\");\n\nconst PooledResource = require(\"./PooledResource\");\n\nconst DefaultEvictor = require(\"./DefaultEvictor\");\n\nconst Deque = require(\"./Deque\");\n\nconst Deferred = require(\"./Deferred\");\n\nconst PriorityQueue = require(\"./PriorityQueue\");\n\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n/**\n * TODO: move me\n */\n\n\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n    factoryValidator(factory);\n    this._config = new PoolOptions(options); // TODO: fix up this ugly glue-ing\n\n    this._Promise = this._config.Promise;\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n\n    this._factoryCreateOperations = new Set();\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n\n    this._factoryDestroyOperations = new Set();\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n\n    this._availableObjects = new Deque();\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n\n    this._testOnBorrowResources = new Set();\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n\n    this._testOnReturnResources = new Set();\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n\n    this._validationOperations = new Set();\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n\n    this._allObjects = new Set();\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n\n    this._resourceLoans = new Map();\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n\n    this._evictionIterator = this._availableObjects.iterator();\n    this._evictor = new Evictor();\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n\n    this._scheduledEviction = null; // create initial resources (if factory.min > 0)\n\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n\n    this._allObjects.delete(pooledResource); // NOTE: this maybe very bad promise usage?\n\n\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n\n    const wrappedDestroyPromise = this._config.destroyTimeoutMillis ? this._Promise.resolve(this._applyDestroyTimeout(destroyPromise)) : this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    }); // TODO: maybe ensuring minimum pool size should live outside here\n\n\n    this._ensureMinimum();\n  }\n\n  _applyDestroyTimeout(promise) {\n    const timeoutPromise = new this._Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(new Error(\"destroy timed out\"));\n      }, this._config.destroyTimeoutMillis).unref();\n    });\n    return this._Promise.race([timeoutPromise, promise]);\n  }\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n\n\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift(); // Mark the resource as in test\n\n\n    pooledResource.test();\n\n    this._testOnBorrowResources.add(pooledResource);\n\n    const validationPromise = this._factory.validate(pooledResource.obj);\n\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(wrappedValidationPromise, this._validationOperations).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n\n        this._destroy(pooledResource);\n\n        this._dispense();\n\n        return;\n      }\n\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n\n\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n\n    return false;\n  }\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n\n\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length; // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;\n    const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);\n\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    } // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n\n\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);\n\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    } // if we aren't testing-on-borrow then lets try to allocate what we can\n\n\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);\n\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n\n\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n\n    if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource); // TODO: do need to trigger anything before we leave?\n\n\n      return false;\n    }\n\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n\n    this._resourceLoans.set(pooledResource.obj, loan);\n\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n\n\n  _trackOperation(operation, set) {\n    set.add(operation);\n    return operation.then(v => {\n      set.delete(operation);\n      return this._Promise.resolve(v);\n    }, e => {\n      set.delete(operation);\n      return this._Promise.reject(e);\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n\n    const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then(resource => {\n      const pooledResource = new PooledResource(resource);\n\n      this._allObjects.add(pooledResource);\n\n      this._addPooledResourceToAvailableObjects(pooledResource);\n    });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {\n      this._dispense(); // Stop bluebird complaining about this side-effect only handler\n      // - a promise was created in a handler but was not returned from it\n      // https://goo.gl/rRqMUw\n\n\n      return null;\n    }).catch(reason => {\n      this.emit(FACTORY_CREATE_ERROR, reason);\n\n      this._dispense();\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n\n    const minShortfall = this._config.min - this._count;\n\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun;) {\n      const iterationResult = this._evictionIterator.next(); // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after checking its length.\n\n\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n\n        return;\n      } // If this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n\n\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);\n\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n\n    if (this._started === true) {\n      return;\n    }\n\n    this._started = true;\n\n    this._scheduleEvictorRun();\n\n    this._ensureMinimum();\n  }\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n\n\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n    } // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n\n\n    if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {\n      return this._Promise.reject(new Error(\"max waitingClients count exceeded\"));\n    }\n\n    const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);\n\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n\n\n  use(fn, priority) {\n    return this.acquire(priority).then(resource => {\n      return fn(resource).then(result => {\n        this.release(resource);\n        return result;\n      }, err => {\n        this.destroy(resource);\n        throw err;\n      });\n    });\n  }\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n\n\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n\n\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n\n\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._destroy(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n\n\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled().then(() => {\n      return this.__allResourcesReturned();\n    }).then(() => {\n      this._descheduleEvictorRun();\n    });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n\n    return this._Promise.resolve();\n  } // FIXME: this is a horrific mess\n\n\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values()).map(loan => loan.promise).map(reflector);\n    return this._Promise.all(ps);\n  }\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n\n\n  clear() {\n    const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector); // wait for outstanding factory.create to complete\n\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n\n      const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n  /**\n   * Waits until the pool is ready.\n   * We define ready by checking if the current resource number is at least\n   * the minimum number defined.\n   * @returns {Promise} that resolves when the minimum number is ready.\n   */\n\n\n  ready() {\n    return new this._Promise(resolve => {\n      const isReady = () => {\n        if (this.available >= this.min) {\n          resolve();\n        } else {\n          setTimeout(isReady, 100);\n        }\n      };\n\n      isReady();\n    });\n  }\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n\n\n  get _potentiallyAllocableResourceCount() {\n    return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n\n\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n\n\n  get spareResourceCapacity() {\n    return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);\n  }\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n\n\n  get size() {\n    return this._count;\n  }\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n\n\n  get available() {\n    return this._availableObjects.length;\n  }\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n\n\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n\n\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get max() {\n    return this._config.max;\n  }\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get min() {\n    return this._config.min;\n  }\n\n}\n\nmodule.exports = Pool;","map":{"version":3,"sources":["/home/maira/Desktop/Developer Projects/system-ping-project/node_modules/generic-pool/lib/Pool.js"],"names":["EventEmitter","require","factoryValidator","PoolOptions","ResourceRequest","ResourceLoan","PooledResource","DefaultEvictor","Deque","Deferred","PriorityQueue","DequeIterator","reflector","FACTORY_CREATE_ERROR","FACTORY_DESTROY_ERROR","Pool","constructor","Evictor","factory","options","_config","_Promise","Promise","_factory","_draining","_started","_waitingClientsQueue","priorityRange","_factoryCreateOperations","Set","_factoryDestroyOperations","_availableObjects","_testOnBorrowResources","_testOnReturnResources","_validationOperations","_allObjects","_resourceLoans","Map","_evictionIterator","iterator","_evictor","_scheduledEviction","autostart","start","_destroy","pooledResource","invalidate","delete","destroyPromise","destroy","obj","wrappedDestroyPromise","destroyTimeoutMillis","resolve","_applyDestroyTimeout","_trackOperation","catch","reason","emit","_ensureMinimum","promise","timeoutPromise","reject","setTimeout","Error","unref","race","_testOnBorrow","length","shift","test","add","validationPromise","validate","wrappedValidationPromise","then","isValid","_dispense","_dispatchPooledResourceToNextWaitingClient","_dispatchResource","numWaitingClients","resourceShortfall","_potentiallyAllocableResourceCount","actualNumberOfResourcesToCreate","Math","min","spareResourceCapacity","i","_createResource","testOnBorrow","desiredNumberOfResourcesToMoveIntoTest","size","actualNumberOfResourcesToMoveIntoTest","actualNumberOfResourcesToDispatch","clientResourceRequest","dequeue","undefined","state","PENDING","_addPooledResourceToAvailableObjects","loan","set","allocate","operation","v","e","factoryPromise","create","wrappedFactoryPromise","resource","minShortfall","_count","_evict","testsToRun","numTestsPerEvictionRun","evictionConfig","softIdleTimeoutMillis","idleTimeoutMillis","testsHaveRun","iterationResult","next","done","reset","value","shouldEvict","evict","remove","_scheduleEvictorRun","evictionRunIntervalMillis","_descheduleEvictorRun","clearTimeout","acquire","priority","maxWaitingClients","resourceRequest","acquireTimeoutMillis","enqueue","use","fn","result","release","err","isBorrowedResource","has","get","deallocate","idle","fifo","push","unshift","drain","__allResourceRequestsSettled","__allResourcesReturned","tail","ps","Array","from","values","map","all","clear","reflectedCreatePromises","reflectedDestroyPromises","ready","isReady","available","max","borrowed","pending","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\nconst PoolOptions = require(\"./PoolOptions\");\nconst ResourceRequest = require(\"./ResourceRequest\");\nconst ResourceLoan = require(\"./ResourceLoan\");\nconst PooledResource = require(\"./PooledResource\");\nconst DefaultEvictor = require(\"./DefaultEvictor\");\nconst Deque = require(\"./Deque\");\nconst Deferred = require(\"./Deferred\");\nconst PriorityQueue = require(\"./PriorityQueue\");\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n\n/**\n * TODO: move me\n */\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n\n    factoryValidator(factory);\n\n    this._config = new PoolOptions(options);\n\n    // TODO: fix up this ugly glue-ing\n    this._Promise = this._config.Promise;\n\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n    this._factoryCreateOperations = new Set();\n\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n    this._factoryDestroyOperations = new Set();\n\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n    this._availableObjects = new Deque();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n    this._testOnBorrowResources = new Set();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n    this._testOnReturnResources = new Set();\n\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n    this._validationOperations = new Set();\n\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n    this._allObjects = new Set();\n\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n    this._resourceLoans = new Map();\n\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n    this._evictionIterator = this._availableObjects.iterator();\n\n    this._evictor = new Evictor();\n\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n    this._scheduledEviction = null;\n\n    // create initial resources (if factory.min > 0)\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n    this._allObjects.delete(pooledResource);\n    // NOTE: this maybe very bad promise usage?\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n    const wrappedDestroyPromise = this._config.destroyTimeoutMillis\n      ? this._Promise.resolve(this._applyDestroyTimeout(destroyPromise))\n      : this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(\n      wrappedDestroyPromise,\n      this._factoryDestroyOperations\n    ).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    });\n\n    // TODO: maybe ensuring minimum pool size should live outside here\n    this._ensureMinimum();\n  }\n\n  _applyDestroyTimeout(promise) {\n    const timeoutPromise = new this._Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(new Error(\"destroy timed out\"));\n      }, this._config.destroyTimeoutMillis).unref();\n    });\n    return this._Promise.race([timeoutPromise, promise]);\n  }\n\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    // Mark the resource as in test\n    pooledResource.test();\n    this._testOnBorrowResources.add(pooledResource);\n    const validationPromise = this._factory.validate(pooledResource.obj);\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(\n      wrappedValidationPromise,\n      this._validationOperations\n    ).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n        this._destroy(pooledResource);\n        this._dispense();\n        return;\n      }\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    return false;\n  }\n\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length;\n\n    // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall =\n      numWaitingClients - this._potentiallyAllocableResourceCount;\n\n    const actualNumberOfResourcesToCreate = Math.min(\n      this.spareResourceCapacity,\n      resourceShortfall\n    );\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    }\n\n    // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest =\n        numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(\n        this._availableObjects.length,\n        desiredNumberOfResourcesToMoveIntoTest\n      );\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    }\n\n    // if we aren't testing-on-borrow then lets try to allocate what we can\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(\n        this._availableObjects.length,\n        numWaitingClients\n      );\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n    if (\n      clientResourceRequest === undefined ||\n      clientResourceRequest.state !== Deferred.PENDING\n    ) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource);\n      // TODO: do need to trigger anything before we leave?\n      return false;\n    }\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n    this._resourceLoans.set(pooledResource.obj, loan);\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n  _trackOperation(operation, set) {\n    set.add(operation);\n\n    return operation.then(\n      v => {\n        set.delete(operation);\n        return this._Promise.resolve(v);\n      },\n      e => {\n        set.delete(operation);\n        return this._Promise.reject(e);\n      }\n    );\n  }\n\n  /**\n   * @private\n   */\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n    const wrappedFactoryPromise = this._Promise\n      .resolve(factoryPromise)\n      .then(resource => {\n        const pooledResource = new PooledResource(resource);\n        this._allObjects.add(pooledResource);\n        this._addPooledResourceToAvailableObjects(pooledResource);\n      });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations)\n      .then(() => {\n        this._dispense();\n        // Stop bluebird complaining about this side-effect only handler\n        // - a promise was created in a handler but was not returned from it\n        // https://goo.gl/rRqMUw\n        return null;\n      })\n      .catch(reason => {\n        this.emit(FACTORY_CREATE_ERROR, reason);\n        this._dispense();\n      });\n  }\n\n  /**\n   * @private\n   */\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n    const minShortfall = this._config.min - this._count;\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(\n      this._config.numTestsPerEvictionRun,\n      this._availableObjects.length\n    );\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun; ) {\n      const iterationResult = this._evictionIterator.next();\n\n      // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after checking its length.\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n        return;\n      }\n      // If this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(\n        evictionConfig,\n        resource,\n        this._availableObjects.length\n      );\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n    if (this._started === true) {\n      return;\n    }\n    this._started = true;\n    this._scheduleEvictorRun();\n    this._ensureMinimum();\n  }\n\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(\n        new Error(\"pool is draining and cannot accept work\")\n      );\n    }\n\n    // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n    if (\n      this.spareResourceCapacity < 1 &&\n      this._availableObjects.length < 1 &&\n      this._config.maxWaitingClients !== undefined &&\n      this._waitingClientsQueue.length >= this._config.maxWaitingClients\n    ) {\n      return this._Promise.reject(\n        new Error(\"max waitingClients count exceeded\")\n      );\n    }\n\n    const resourceRequest = new ResourceRequest(\n      this._config.acquireTimeoutMillis,\n      this._Promise\n    );\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n  use(fn, priority) {\n    return this.acquire(priority).then(resource => {\n      return fn(resource).then(\n        result => {\n          this.release(resource);\n          return result;\n        },\n        err => {\n          this.destroy(resource);\n          throw err;\n        }\n      );\n    });\n  }\n\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._destroy(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled()\n      .then(() => {\n        return this.__allResourcesReturned();\n      })\n      .then(() => {\n        this._descheduleEvictorRun();\n      });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n    return this._Promise.resolve();\n  }\n\n  // FIXME: this is a horrific mess\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values())\n      .map(loan => loan.promise)\n      .map(reflector);\n    return this._Promise.all(ps);\n  }\n\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n  clear() {\n    const reflectedCreatePromises = Array.from(\n      this._factoryCreateOperations\n    ).map(reflector);\n\n    // wait for outstanding factory.create to complete\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n      const reflectedDestroyPromises = Array.from(\n        this._factoryDestroyOperations\n      ).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n\n  /**\n   * Waits until the pool is ready.\n   * We define ready by checking if the current resource number is at least\n   * the minimum number defined.\n   * @returns {Promise} that resolves when the minimum number is ready.\n   */\n  ready() {\n    return new this._Promise(resolve => {\n      const isReady = () => {\n        if (this.available >= this.min) {\n          resolve();\n        } else {\n          setTimeout(isReady, 100);\n        }\n      };\n\n      isReady();\n    });\n  }\n\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n  get _potentiallyAllocableResourceCount() {\n    return (\n      this._availableObjects.length +\n      this._testOnBorrowResources.size +\n      this._testOnReturnResources.size +\n      this._factoryCreateOperations.size\n    );\n  }\n\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n  get spareResourceCapacity() {\n    return (\n      this._config.max -\n      (this._allObjects.size + this._factoryCreateOperations.size)\n    );\n  }\n\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n  get size() {\n    return this._count;\n  }\n\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n  get max() {\n    return this._config.max;\n  }\n\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n  get min() {\n    return this._config.min;\n  }\n}\n\nmodule.exports = Pool;\n"]},"metadata":{},"sourceType":"script"}